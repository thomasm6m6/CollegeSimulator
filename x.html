<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>College Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }

        /* Buttons container */
        .top-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
        }

        .top-buttons button {
            padding: 8px;
            border: none;
            background-color: #fff;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .top-buttons button:hover {
            background-color: #f0f0f0;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            width: 300px;
            font-family: Arial, sans-serif;
            z-index: 1001;
        }

        .modal.active {
            display: block;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            border: none;
            background: none;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
        }

        /* Checkbox styling */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }

        .checkbox-container input[type="checkbox"] {
            display: none;
        }

        .checkbox-container label {
            position: relative;
            padding-left: 30px;
            cursor: pointer;
            font-size: 14px;
            user-select: none;
        }

        .checkbox-container label:before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            border: 2px solid #ccc;
            border-radius: 4px;
            background: #fff;
        }

        .checkbox-container input:checked + label:before {
            background: #007bff;
            border-color: #007bff;
        }

        .checkbox-container input:checked + label:after {
            content: '✔';
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-size: 12px;
        }

        /* Dropdown styling */
        .dropdown-container {
            margin: 15px 0;
        }

        .dropdown-container select {
            width: 100%;
            padding: 8px;
            border: 2px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            background: #fff;
            appearance: none;
            cursor: pointer;
        }

        .dropdown-container select:focus {
            outline: none;
            border-color: #007bff;
        }

        /* Backdrop styles */
        .backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black */
            z-index: 1000; /* Below modal, above everything else */
        }

        .backdrop.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="top-buttons">
        <button id="settings-btn">
            <img src="icons/settings.svg" alt="Settings" width="24" height="24">
        </button>
        <button id="about-btn">
            <img src="icons/about.svg" alt="About" width="24" height="24">
        </button>
    </div>

    <!-- Backdrop -->
    <div class="backdrop" id="backdrop"></div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <button class="close-btn" id="close-settings">×</button>
        <h2>Settings</h2>
        <div class="checkbox-container">
            <input type="checkbox" id="adult-content" name="adult-content">
            <label for="adult-content">18+</label>
        </div>
        <div class="dropdown-container">
            <select id="role-switch">
                <option value="student">Student</option>
                <option value="professor">Professor</option>
                <option value="administrator">Administrator</option>
            </select>
        </div>
    </div>

    <!-- About Modal -->
    <div id="about-modal" class="modal">
        <button class="close-btn" id="close-about">×</button>
        <h2>About</h2>
        <p>
            Welcome to Springfield University!
            This game was built in a week for the 2025 Vibe Coding Game Jam.
        </p>
        <p><em>Made with</em> ☕️ <em>by <a href="https://x.com/thomasm6m6">Thomas M</a></em>.</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // Function to load pixel art textures with proper settings
        function loadPixelArtTexture(url) {
            const texture = textureLoader.load(url);
            texture.minFilter = THREE.NearestFilter; // Use nearest neighbor for minification
            texture.magFilter = THREE.NearestFilter; // Use nearest neighbor for magnification
            texture.wrapS = THREE.RepeatWrapping;    // Optional: Adjust wrapping if tiling
            texture.wrapT = THREE.RepeatWrapping;
            // texture.repeat.set(1, 1);             // Optional: Set repeat if needed
            return texture;
        }

        const outerWallMaterial = new THREE.MeshBasicMaterial({ map: loadPixelArtTexture('textures/outer_wall.png') });
        const wallMaterial = new THREE.MeshBasicMaterial({ map: loadPixelArtTexture('textures/inner_wall.png'), polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1 });
        const floorMaterial = new THREE.MeshBasicMaterial({ map: loadPixelArtTexture('textures/floor.png') });
        const rampMaterial = new THREE.MeshBasicMaterial({ map: loadPixelArtTexture('textures/ramp.png') });
        const pathMaterial = new THREE.MeshBasicMaterial({ map: loadPixelArtTexture('textures/path.png') });
        const groundMaterial = new THREE.MeshBasicMaterial({
            map: loadPixelArtTexture('textures/grass.png'),
            side: THREE.DoubleSide
        });

        const shrubMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 }); // Forest green
        const lampPoleMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 }); // Dark gray
        const lampLightMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF99 }); // Light yellow
        const grassMaterial = new THREE.MeshBasicMaterial({ color: 0x32CD32 }); // Lime green

        // Player
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        scene.add(player);
        player.position.set(0, 0.5, 0);

        // Ground
        const tileSize = 10;
        const gridSize = 20;
        const totalSize = tileSize * gridSize;
        const groundGeometry = new THREE.PlaneGeometry(totalSize, totalSize, gridSize, gridSize);
        groundMaterial.map.repeat.set(gridSize, gridSize);
        groundMaterial.map.wrapS = THREE.RepeatWrapping;
        groundMaterial.map.wrapT = THREE.RepeatWrapping;

        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.set(0, 0, 0);
        scene.add(ground);

        // Movement controls
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };
        let currentBuilding = null;
        let currentFloor = 0;

        // Camera variables
        let cameraDistance = 10;
        const cameraDistanceOutside = 10;
        const cameraDistanceInside = 6;
        const minCameraDistance = 2;
        const maxCameraDistance = 10;
        let targetCameraDistance = cameraDistanceOutside;
        let cameraYaw = Math.PI;
        let cameraPitch = Math.PI / 6;
        const pitchMin = 0;
        const pitchMax = Math.PI / 3;
        const mouseSensitivity = 0.002;

        // Add modal and button functionality
        const settingsBtn = document.getElementById('settings-btn');
        const aboutBtn = document.getElementById('about-btn');
        const settingsModal = document.getElementById('settings-modal');
        const aboutModal = document.getElementById('about-modal');
        const closeSettings = document.getElementById('close-settings');
        const closeAbout = document.getElementById('close-about');
        const topButtons = document.querySelector('.top-buttons');
        const backdrop = document.getElementById('backdrop');

        function toggleModal(modal, otherModal, show) {
            if (show) {
                modal.classList.add('active');
                backdrop.classList.add('active');
                otherModal.classList.remove('active');
            } else {
                modal.classList.remove('active');
                backdrop.classList.remove('active');
            }
        }

        // Toggle modals
        settingsBtn.addEventListener('click', () => {
            event.stopPropagation();
            toggleModal(settingsModal, aboutModal, !settingsModal.classList.contains('active'));
        });

        aboutBtn.addEventListener('click', () => {
            event.stopPropagation();
            toggleModal(aboutModal, settingsModal, !aboutModal.classList.contains('active'));
        });

        closeSettings.addEventListener('click', () => {
            event.stopPropagation();
            toggleModal(settingsModal, aboutModal, false);
        });

        closeAbout.addEventListener('click', () => {
            event.stopPropagation();
            toggleModal(aboutModal, settingsModal, false);
        });

        backdrop.addEventListener('click', () => {
            event.stopPropagation();
            toggleModal(settingsModal, aboutModal, false);
            toggleModal(aboutModal, settingsModal, false);
        })

        settingsModal.addEventListener('click', (event) => {
            event.stopPropagation();
        });

        aboutModal.addEventListener('click', (event) => {
            event.stopPropagation();
        });

        // Hide buttons when pointer is locked
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) {
                topButtons.style.display = 'none';
            } else {
                topButtons.style.display = 'flex';
            }
        });

        // Lock mouse and hide cursor
        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;
        document.addEventListener('click', () => document.body.requestPointerLock());

        // Event listeners
        document.addEventListener('keydown', (event) => {
            if (event.key in keys) keys[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            if (event.key in keys) keys[event.key] = false;
        });
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body) {
                cameraYaw -= event.movementX * mouseSensitivity;
                cameraPitch -= event.movementY * mouseSensitivity;
                cameraPitch = Math.max(pitchMin, Math.min(pitchMax, cameraPitch));
            }
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Simple seeded RNG for consistency
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // Modified function to generate floor layout with Z-offset to prevent z-fighting
        function generateFloorLayout(type, width, depth, floor, seed, buildingPosition) {
            const cellSize = 4;
            const gridX = Math.floor(width / cellSize);
            const gridZ = Math.floor(depth / cellSize);
            const layout = new Array(gridX * gridZ).fill('empty');
            const meshes = [];
            const collisionBoxes = [];
            const wallThickness = 0.2;
            const Z_OFFSET = 0.01; // Small offset to prevent z-fighting

            const floorSeed = seed + floor;

            if (type === 'dorm') {
                const corridorX = Math.floor(gridX / 2);
                for (let z = 0; z < gridZ; z++) {
                    layout[corridorX * gridZ + z] = 'corridor';
                }
                for (let x = 0; x < gridX; x++) {
                    if (x !== corridorX && seededRandom(floorSeed + x) > 0.4) {
                        const z = Math.floor(seededRandom(floorSeed + x + 1) * gridZ);
                        layout[x * gridZ + z] = 'room';
                        if (x < corridorX) {
                            const wall = new THREE.Mesh(
                                new THREE.BoxGeometry(wallThickness, 3, cellSize),
                                wallMaterial
                            );
                            wall.position.set(
                                buildingPosition.x + (x + 0.5) * cellSize - width / 2,
                                buildingPosition.y + floor * 3 + 1.5,
                                buildingPosition.z + z * cellSize - depth / 2 + cellSize / 2
                            );
                            meshes.push(wall);
                            collisionBoxes.push(new THREE.Box3().setFromObject(wall));
                        } else {
                            const wall = new THREE.Mesh(
                                new THREE.BoxGeometry(wallThickness, 3, cellSize),
                                wallMaterial
                            );
                            wall.position.set(
                                buildingPosition.x + (x - 0.5) * cellSize - width / 2,
                                buildingPosition.y + floor * 3 + 1.5,
                                buildingPosition.z + z * cellSize - depth / 2 + cellSize / 2
                            );
                            meshes.push(wall);
                            collisionBoxes.push(new THREE.Box3().setFromObject(wall));
                        }
                    }
                }
            } else if (type === 'classroom') {
                const roomCount = Math.floor(seededRandom(floorSeed) * 3) + 1;
                for (let i = 0; i < roomCount; i++) {
                    const sizeX = Math.floor(seededRandom(floorSeed + i) * 3 + 1) * cellSize;
                    const sizeZ = Math.floor(seededRandom(floorSeed + i + 1) * 2 + 1) * cellSize;
                    const x = Math.floor(seededRandom(floorSeed + i + 2) * (gridX - sizeX / cellSize));
                    const z = Math.floor(seededRandom(floorSeed + i + 3) * (gridZ - sizeZ / cellSize));
                    for (let dx = x; dx < x + sizeX / cellSize; dx++) {
                        for (let dz = z; dz < z + sizeZ / cellSize; dz++) {
                            if (dx < gridX && dz < gridZ) layout[dx * gridZ + dz] = 'room';
                        }
                    }
                    const walls = [
                        new THREE.Mesh(new THREE.BoxGeometry(sizeX, 3, wallThickness), wallMaterial),
                        new THREE.Mesh(new THREE.BoxGeometry(sizeX, 3, wallThickness), wallMaterial),
                        new THREE.Mesh(new THREE.BoxGeometry(wallThickness, 3, sizeZ), wallMaterial),
                        new THREE.Mesh(new THREE.BoxGeometry(wallThickness, 3, sizeZ), wallMaterial)
                    ];
                    walls[0].position.set(
                        buildingPosition.x + x * cellSize - width / 2 + sizeX / 2,
                        buildingPosition.y + floor * 3 + 1.5,
                        buildingPosition.z + z * cellSize - depth / 2 + sizeZ + Z_OFFSET // Add Z-offset
                    );
                    walls[1].position.set(
                        buildingPosition.x + x * cellSize - width / 2 + sizeX / 2,
                        buildingPosition.y + floor * 3 + 1.5,
                        buildingPosition.z + z * cellSize - depth / 2 - Z_OFFSET // Add Z-offset
                    );
                    walls[2].position.set(
                        buildingPosition.x + x * cellSize - width / 2 - Z_OFFSET, // Add Z-offset
                        buildingPosition.y + floor * 3 + 1.5,
                        buildingPosition.z + z * cellSize - depth / 2 + sizeZ / 2
                    );
                    walls[3].position.set(
                        buildingPosition.x + x * cellSize - width / 2 + sizeX + Z_OFFSET, // Add Z-offset
                        buildingPosition.y + floor * 3 + 1.5,
                        buildingPosition.z + z * cellSize - depth / 2 + sizeZ / 2
                    );
                    meshes.push(...walls);
                    collisionBoxes.push(...walls.map(w => new THREE.Box3().setFromObject(w)));
                }
            } else if (type === 'misc') {
                for (let i = 0; i < 3; i++) {
                    const x = Math.floor(seededRandom(floorSeed + i) * gridX);
                    const z = Math.floor(seededRandom(floorSeed + i + 1) * gridZ);
                    layout[x * gridZ + z] = 'room';
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(cellSize, 3, wallThickness),
                        wallMaterial
                    );
                    wall.position.set(
                        buildingPosition.x + x * cellSize - width / 2 + cellSize / 2,
                        buildingPosition.y + floor * 3 + 1.5,
                        buildingPosition.z + z * cellSize - depth / 2 + cellSize + Z_OFFSET // Add Z-offset
                    );
                    meshes.push(wall);
                    collisionBoxes.push(new THREE.Box3().setFromObject(wall));
                }
            }

            return { meshes, collisionBoxes, floorMaterial };
        }

        // Building creation function with Z-offsets to prevent z-fighting
        function createBuilding(type, position) {
            const floorHeight = 3;
            let floors, width, depth;
            if (type === 'dorm') { floors = 4; width = 20; depth = 20; }
            else if (type === 'classroom') { floors = 3; width = 25; depth = 25; }
            else { floors = 1; width = 15; depth = 15; }
            const totalHeight = floors * floorHeight;
            const meshes = [];
            const floorMeshes = [];
            const outerCollisionBoxes = [];
            const innerCollisionBoxes = [];
            const rampPositions = [];
            const wallThickness = 0.2;
            const Z_OFFSET = 0.01; // Small offset to prevent z-fighting

            const seed = Math.abs(Math.floor(position.x * 100 + position.z * 1000));

            for (let f = 0; f < floors; f++) {
                outerCollisionBoxes[f] = [];
                if (f === 0) {
                    const doorWidth = 8;
                    const frontWallLeft = new THREE.Mesh(
                        new THREE.BoxGeometry((width - doorWidth) / 2, floorHeight, wallThickness),
                        outerWallMaterial
                    );
                    frontWallLeft.position.set(
                        position.x - width / 4,
                        position.y + f * floorHeight + floorHeight / 2,
                        position.z - depth / 2 - Z_OFFSET // Add Z-offset
                    );
                    const frontWallRight = new THREE.Mesh(
                        new THREE.BoxGeometry((width - doorWidth) / 2, floorHeight, wallThickness),
                        outerWallMaterial
                    );
                    frontWallRight.position.set(
                        position.x + width / 4,
                        position.y + f * floorHeight + floorHeight / 2,
                        position.z - depth / 2 - Z_OFFSET // Add Z-offset
                    );
                    meshes.push(frontWallLeft, frontWallRight);
                    outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(frontWallLeft), new THREE.Box3().setFromObject(frontWallRight));
                } else {
                    const frontWall = new THREE.Mesh(
                        new THREE.BoxGeometry(width, floorHeight, wallThickness),
                        outerWallMaterial
                    );
                    frontWall.position.set(
                        position.x,
                        position.y + f * floorHeight + floorHeight / 2,
                        position.z - depth / 2 - Z_OFFSET // Add Z-offset
                    );
                    meshes.push(frontWall);
                    outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(frontWall));
                }

                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(width, floorHeight, wallThickness),
                    outerWallMaterial
                );
                backWall.position.set(
                    position.x,
                    position.y + f * floorHeight + floorHeight / 2,
                    position.z + depth / 2 + Z_OFFSET // Add Z-offset
                );
                meshes.push(backWall);
                outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(backWall));

                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, floorHeight, depth),
                    outerWallMaterial
                );
                leftWall.position.set(
                    position.x - width / 2 - Z_OFFSET, // Add Z-offset
                    position.y + f * floorHeight + floorHeight / 2,
                    position.z
                );
                meshes.push(leftWall);
                outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(leftWall));

                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, floorHeight, depth),
                    outerWallMaterial
                );
                rightWall.position.set(
                    position.x + width / 2 + Z_OFFSET, // Add Z-offset
                    position.y + f * floorHeight + floorHeight / 2,
                    position.z
                );
                meshes.push(rightWall);
                outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(rightWall));
            }

            for (let f = 0; f < floors; f++) {
                const floorGeometry = new THREE.PlaneGeometry(width, depth);
                // Pass the building position to generateFloorLayout
                const { meshes: innerMeshes, collisionBoxes: innerBoxes, floorMaterial } = generateFloorLayout(type, width, depth, f, seed, position);
                const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                floorMesh.rotation.x = -Math.PI / 2;
                // Add a small y offset to prevent z-fighting with ground
                floorMesh.position.set(position.x, position.y + f * floorHeight + Z_OFFSET, position.z);
                meshes.push(floorMesh, ...innerMeshes);
                floorMeshes.push(floorMesh);
                innerCollisionBoxes[f] = innerBoxes;
            }

            if (floors > 1 && (type === 'classroom' || type === 'dorm')) {
                for (let f = 0; f < floors - 1; f++) {
                    const rampWidth = 2;
                    const rampLength = 4;
                    const rampHeight = floorHeight;
                    const rampGeometry = new THREE.PlaneGeometry(rampWidth, Math.sqrt(rampLength * rampLength + rampHeight * rampHeight));
                    const rampMesh = new THREE.Mesh(rampGeometry, rampMaterial);
                    const rampX = position.x + (type === 'classroom' ? 10 : 8);
                    const rampZ = position.z - 10;
                    const rampY = position.y + f * floorHeight + rampHeight / 2;
                    rampMesh.position.set(rampX, rampY, rampZ);
                    const angle = Math.atan2(rampHeight, rampLength);
                    rampMesh.rotation.x = -angle;
                    // Add a small offset to prevent z-fighting
                    rampMesh.position.y += Z_OFFSET;
                    meshes.push(rampMesh);
                    const rampStartZ = rampZ - rampLength / 2;
                    const rampEndZ = rampZ + rampLength / 2;
                    const rampStartY = position.y + f * floorHeight;
                    const rampEndY = position.y + (f + 1) * floorHeight;
                    rampPositions[f] = { x: rampX, startZ: rampStartZ, endZ: rampEndZ, startY: rampStartY, endY: rampEndY, floor: f };
                }
            }

            const buildingBox = new THREE.Box3().setFromCenterAndSize(position, new THREE.Vector3(width, totalHeight, depth));
            return { meshes, floorMeshes, outerCollisionBoxes, innerCollisionBoxes, rampPositions, buildingBox, floors, floorHeight, position };
        }

        // Modified environment generation to prevent z-fighting
        function generateEnvironment(buildings) {
            const envMeshes = [];
            const globalSeed = 42; // Fixed seed for consistency
            const Z_OFFSET = 0.01; // Small offset to prevent z-fighting

            // Paths
            const entrances = buildings.map(b => ({
                x: b.position.x,
                z: b.position.z - (b.buildingBox.max.z - b.buildingBox.min.z) / 2
            }));
            const paths = [];
            for (let i = 1; i < entrances.length; i++) {
                const start = entrances[i - 1];
                const end = entrances[i];
                const pathWidth = 2;
                const length = Math.sqrt((end.x - start.x) ** 2 + (end.z - start.z) ** 2);
                const pathGeometry = new THREE.PlaneGeometry(length, pathWidth);
                const pathMesh = new THREE.Mesh(pathGeometry, pathMaterial);
                // Elevate paths slightly above ground to prevent z-fighting
                pathMesh.position.set((start.x + end.x) / 2, 0.01 + Z_OFFSET, (start.z + end.z) / 2);
                pathMesh.rotation.y = Math.atan2(end.x - start.x, end.z - start.z);
                pathMesh.rotation.x = -Math.PI / 2;
                paths.push(pathMesh);
                envMeshes.push(pathMesh);
            }

            // Streetlamps along paths
            paths.forEach((path, index) => {
                const pathLength = path.geometry.parameters.width;
                const lampCount = Math.floor(pathLength / 10); // One every ~10 units
                const startPos = new THREE.Vector3().copy(entrances[index]);
                const endPos = new THREE.Vector3().copy(entrances[index + 1]);
                const direction = endPos.clone().sub(startPos).normalize();

                for (let i = 0; i < lampCount; i++) {
                    const t = (i + 1) / (lampCount + 1);
                    const pos = startPos.clone().lerp(endPos, t);
                    pos.y = 0;

                    // Slight offset from path center
                    const offset = direction.clone().cross(new THREE.Vector3(0, 1, 0)).multiplyScalar((seededRandom(globalSeed + i + index) > 0.5 ? 1 : -1) * 1.5);

                    const pole = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 4, 8),
                        lampPoleMaterial
                    );
                    pole.position.copy(pos).add(offset);
                    pole.position.y = 2; // Half height

                    const light = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 8, 8),
                        lampLightMaterial
                    );
                    light.position.copy(pole.position).add(new THREE.Vector3(0, 2, 0));

                    envMeshes.push(pole, light);
                }
            });

            // Shrubs
            const shrubCount = 50; // Arbitrary number
            for (let i = 0; i < shrubCount; i++) {
                const x = (seededRandom(globalSeed + i) * 200) - 100;
                const z = (seededRandom(globalSeed + i + 1) * 200) - 100;
                let valid = true;

                // Avoid buildings and paths
                for (let b of buildings) {
                    if (b.buildingBox.containsPoint(new THREE.Vector3(x, 0, z))) {
                        valid = false;
                        break;
                    }
                }
                for (let p of paths) {
                    const box = new THREE.Box3().setFromObject(p).expandByScalar(1);
                    if (box.containsPoint(new THREE.Vector3(x, 0, z))) {
                        valid = false;
                        break;
                    }
                }

                if (valid) {
                    const shrub = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.8, 1.5, 8),
                        shrubMaterial
                    );
                    shrub.position.set(x, 0.75, z);
                    envMeshes.push(shrub);
                }
            }

            // Grass patches
            const grassCount = 30;
            for (let i = 0; i < grassCount; i++) {
                const x = (seededRandom(globalSeed + i + shrubCount) * 200) - 100;
                const z = (seededRandom(globalSeed + i + shrubCount + 1) * 200) - 100;
                let valid = true;

                for (let b of buildings) {
                    if (b.buildingBox.containsPoint(new THREE.Vector3(x, 0, z))) {
                        valid = false;
                        break;
                    }
                }
                for (let p of paths) {
                    const box = new THREE.Box3().setFromObject(p).expandByScalar(1);
                    if (box.containsPoint(new THREE.Vector3(x, 0, z))) {
                        valid = false;
                        break;
                    }
                }

                if (valid) {
                    const grass = new THREE.Mesh(
                        new THREE.PlaneGeometry(3, 3),
                        grassMaterial
                    );
                    grass.rotation.x = -Math.PI / 2;
                    // Set a small offset to prevent z-fighting with ground
                    grass.position.set(x, 0.01 + Z_OFFSET * 2, z);
                    envMeshes.push(grass);
                }
            }

            return envMeshes;
        }

        // Optional: Use a renderer with logarithmic depth buffer for better depth precision
        renderer.logarithmicDepthBuffer = true;

        // Create buildings and environment
        const buildings = [
            createBuilding('dorm', new THREE.Vector3(20, 0, 20)),
            createBuilding('classroom', new THREE.Vector3(50, 0, 50)),
            createBuilding('misc', new THREE.Vector3(80, 0, 80)),
            createBuilding('dorm', new THREE.Vector3(-30, 0, -30))
        ];
        buildings.forEach(building => building.meshes.forEach(mesh => scene.add(mesh)));
        const envMeshes = generateEnvironment(buildings);
        envMeshes.forEach(mesh => scene.add(mesh));

        // Raycaster for camera collision
        const raycaster = new THREE.Raycaster();

        // Modified movement code with wall sliding implementation
        function animate() {
            requestAnimationFrame(animate);

            targetCameraDistance = currentBuilding ? cameraDistanceInside : cameraDistanceOutside;
            cameraDistance += (targetCameraDistance - cameraDistance) * 0.1;
            cameraDistance = Math.max(minCameraDistance, Math.min(maxCameraDistance, cameraDistance));

            const cameraOffset = new THREE.Vector3(
                cameraDistance * Math.sin(cameraYaw) * Math.cos(cameraPitch),
                cameraDistance * Math.sin(cameraPitch),
                cameraDistance * Math.cos(cameraYaw) * Math.cos(cameraPitch)
            );
            const idealCameraPosition = player.position.clone().add(cameraOffset);

            const direction = idealCameraPosition.clone().sub(player.position).normalize();
            raycaster.set(player.position, direction);
            const intersects = raycaster.intersectObjects(scene.children, true);

            let adjustedCameraPosition = idealCameraPosition.clone();
            if (intersects.length > 0 && intersects[0].distance < cameraDistance) {
                const maxDistance = Math.max(minCameraDistance, intersects[0].distance - 0.5);
                adjustedCameraPosition.copy(player.position).add(direction.multiplyScalar(maxDistance));
            }
            adjustedCameraPosition.y = Math.max(adjustedCameraPosition.y, player.position.y - 0.5);
            camera.position.copy(adjustedCameraPosition);
            camera.lookAt(player.position);

            const cameraForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            cameraForward.y = 0;
            cameraForward.normalize();
            const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            cameraRight.y = 0;
            cameraRight.normalize();

            // Calculate movement vector based on input
            const moveVector = new THREE.Vector3(0, 0, 0);
            if (keys.w) moveVector.add(cameraForward.clone().multiplyScalar(moveSpeed));
            if (keys.s) moveVector.add(cameraForward.clone().multiplyScalar(-moveSpeed));
            if (keys.a) moveVector.add(cameraRight.clone().multiplyScalar(-moveSpeed));
            if (keys.d) moveVector.add(cameraRight.clone().multiplyScalar(moveSpeed));

            // If no movement, skip collision detection
            if (moveVector.lengthSq() > 0) {
                let newPosition = player.position.clone().add(moveVector);

                let isInside = false;
                buildings.forEach(building => {
                    if (building.buildingBox.containsPoint(newPosition)) {
                        currentBuilding = building;
                        isInside = true;
                    }
                });

                if (!isInside) {
                    currentBuilding = null;
                    currentFloor = 0;
                    newPosition.y = 0.5;
                } else {
                    currentFloor = Math.round((player.position.y - currentBuilding.position.y - 0.5) / currentBuilding.floorHeight);
                    currentFloor = Math.max(0, Math.min(currentBuilding.floors - 1, currentFloor));

                    let onRamp = false;
                    for (let f = 0; f < currentBuilding.floors - 1; f++) {
                        const ramp = currentBuilding.rampPositions[f];
                        if (Math.abs(newPosition.x - ramp.x) < 1 && newPosition.z >= ramp.startZ && newPosition.z <= ramp.endZ) {
                            const t = (newPosition.z - ramp.startZ) / (ramp.endZ - ramp.startZ);
                            newPosition.y = ramp.startY + t * (ramp.endY - ramp.startY) + 0.5;
                            onRamp = true;
                            break;
                        }
                    }
                    if (!onRamp) {
                        const floorY = currentBuilding.position.y + currentFloor * currentBuilding.floorHeight;
                        newPosition.y = floorY + 0.5;
                    }
                }

                // Implement wall sliding
                const playerRadius = 0.5; // Half the player's width
                const playerHeight = 1.0; // Player's height
                const collisionBoxes = currentBuilding ?
                    [...currentBuilding.outerCollisionBoxes[currentFloor], ...currentBuilding.innerCollisionBoxes[currentFloor]] :
                    buildings.flatMap(building => building.outerCollisionBoxes.flat());

                // First check if the movement would cause a collision
                const playerBox = new THREE.Box3().setFromCenterAndSize(
                    newPosition,
                    new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2)
                );

                let collision = false;
                let collisionNormal = new THREE.Vector3();
                let minPenetration = Infinity;

                for (let box of collisionBoxes) {
                    if (playerBox.intersectsBox(box)) {
                        collision = true;

                        // Calculate collision normal and penetration depth
                        // This is a simplified approach for box-box collision
                        const boxCenter = new THREE.Vector3();
                        box.getCenter(boxCenter);

                        const boxSize = new THREE.Vector3();
                        box.getSize(boxSize);

                        const toBox = boxCenter.clone().sub(newPosition);

                        // Determine the axis of minimum penetration
                        const xOverlap = (playerRadius + boxSize.x/2) - Math.abs(toBox.x);
                        const yOverlap = (playerHeight/2 + boxSize.y/2) - Math.abs(toBox.y);
                        const zOverlap = (playerRadius + boxSize.z/2) - Math.abs(toBox.z);

                        // Find minimum penetration axis
                        if (xOverlap < yOverlap && xOverlap < zOverlap) {
                            collisionNormal.set(Math.sign(toBox.x), 0, 0);
                            if (xOverlap < minPenetration) {
                                minPenetration = xOverlap;
                            }
                        } else if (yOverlap < zOverlap) {
                            collisionNormal.set(0, Math.sign(toBox.y), 0);
                            if (yOverlap < minPenetration) {
                                minPenetration = yOverlap;
                            }
                        } else {
                            collisionNormal.set(0, 0, Math.sign(toBox.z));
                            if (zOverlap < minPenetration) {
                                minPenetration = zOverlap;
                            }
                        }

                        break; // For simplicity, handle one collision at a time
                    }
                }

                if (collision) {
                    // Calculate the angle between movement direction and wall normal
                    const movementDir = moveVector.clone().normalize();
                    const wallAngle = Math.acos(movementDir.dot(collisionNormal));

                    // If the angle is small (nearly parallel to wall), implement sliding
                    if (wallAngle > Math.PI / 4) {  // Greater than 45 degrees means player is moving mostly along the wall
                        // Project movement vector onto the wall plane
                        const dot = moveVector.dot(collisionNormal);
                        const projection = collisionNormal.clone().multiplyScalar(dot);
                        const slideVector = moveVector.clone().sub(projection);

                        // Only apply sliding if the projection has meaningful magnitude
                        if (slideVector.lengthSq() > 0.0001) {
                            // Scale back to original movement magnitude if needed
                            slideVector.normalize().multiplyScalar(moveVector.length() * 0.8); // Slight friction when sliding

                            // Apply the slide instead of the original movement
                            newPosition = player.position.clone().add(slideVector);

                            // Verify the slide position doesn't cause a collision
                            const slideBox = new THREE.Box3().setFromCenterAndSize(
                                newPosition,
                                new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2)
                            );

                            let slideCollision = false;
                            for (let box of collisionBoxes) {
                                if (slideBox.intersectsBox(box)) {
                                    slideCollision = true;
                                    break;
                                }
                            }

                            if (!slideCollision) {
                                player.position.copy(newPosition);
                            }
                        }
                    }
                } else {
                    // No collision, apply movement normally
                    player.position.copy(newPosition);
                }
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>