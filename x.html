<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3D World with Enterable Buildings</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Player
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        scene.add(player);
        player.position.set(0, 0.5, 0);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = Math.PI / 2;
        scene.add(ground);

        // Movement controls
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };
        let currentBuilding = null;
        let currentFloor = 0;

        // Camera variables
        let cameraDistance = 10;
        const cameraDistanceOutside = 10;
        const cameraDistanceInside = 6;
        const minCameraDistance = 2;
        const maxCameraDistance = 10;
        let targetCameraDistance = cameraDistanceOutside;
        let cameraYaw = Math.PI;
        let cameraPitch = Math.PI / 6;
        const pitchMin = 0;
        const pitchMax = Math.PI / 3;
        const mouseSensitivity = 0.002;

        // Lock mouse and hide cursor
        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;
        document.addEventListener('click', () => document.body.requestPointerLock());

        // Event listeners
        document.addEventListener('keydown', (event) => {
            if (event.key in keys) keys[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            if (event.key in keys) keys[event.key] = false;
        });
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body ||
                document.mozPointerLockElement === document.body ||
                document.webkitPointerLockElement === document.body) {
                cameraYaw -= event.movementX * mouseSensitivity;
                cameraPitch -= event.movementY * mouseSensitivity;
                cameraPitch = Math.max(pitchMin, Math.min(pitchMax, cameraPitch));
            }
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Building creation function
        function createBuilding(type, position) {
            const floorHeight = 3;
            let floors, width, depth;
            if (type === 'dorm') { floors = 4; width = 20; depth = 20; }
            else if (type === 'classroom') { floors = 3; width = 25; depth = 25; }
            else { floors = 1; width = 15; depth = 15; }
            const totalHeight = floors * floorHeight;
            const meshes = [];
            const floorMeshes = [];
            const outerCollisionBoxes = [];
            const innerCollisionBoxes = [];
            const rampPositions = [];
            const wallThickness = 0.2;

            // Create outer walls
            for (let f = 0; f < floors; f++) {
                outerCollisionBoxes[f] = [];
                const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
                const doorWidth = type === 'misc' ? 4 : 6;

                if (f === 0) {
                    const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry((width - doorWidth) / 2, floorHeight, wallThickness), wallMaterial);
                    frontWallLeft.position.set(position.x - width / 4, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2);
                    const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry((width - doorWidth) / 2, floorHeight, wallThickness), wallMaterial);
                    frontWallRight.position.set(position.x + width / 4, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2);
                    meshes.push(frontWallLeft, frontWallRight);
                    outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(frontWallLeft));
                    outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(frontWallRight));
                } else {
                    const frontWall = new THREE.Mesh(new THREE.BoxGeometry(width, floorHeight, wallThickness), wallMaterial);
                    frontWall.position.set(position.x, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2);
                    meshes.push(frontWall);
                    outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(frontWall));
                }

                const backWall = new THREE.Mesh(new THREE.BoxGeometry(width, floorHeight, wallThickness), wallMaterial);
                backWall.position.set(position.x, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2);
                meshes.push(backWall);
                outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(backWall));

                const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, depth), wallMaterial);
                leftWall.position.set(position.x - width / 2, position.y + f * floorHeight + floorHeight / 2, position.z);
                meshes.push(leftWall);
                outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(leftWall));

                const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, depth), wallMaterial);
                rightWall.position.set(position.x + width / 2, position.y + f * floorHeight + floorHeight / 2, position.z);
                meshes.push(rightWall);
                outerCollisionBoxes[f].push(new THREE.Box3().setFromObject(rightWall));
            }

            // Create floors and inner layouts
            for (let f = 0; f < floors; f++) {
                const floorGeometry = new THREE.PlaneGeometry(width, depth);
                const floorMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.FrontSide });
                const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                floorMesh.rotation.x = -Math.PI / 2;
                floorMesh.position.set(position.x, position.y + f * floorHeight, position.z);
                meshes.push(floorMesh);
                floorMeshes.push(floorMesh);

                innerCollisionBoxes[f] = [];
                const innerWallMaterial = new THREE.MeshBasicMaterial({ color: 0x777777 });

                if (type === 'classroom') {
                    const lectureHall1Width = 8;
                    const lectureHall1Depth = 6;
                    const lectureHall1Wall1 = new THREE.Mesh(new THREE.BoxGeometry(lectureHall1Width, floorHeight, wallThickness), innerWallMaterial);
                    lectureHall1Wall1.position.set(position.x - width / 2 + lectureHall1Width / 2, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2 + lectureHall1Depth);
                    const lectureHall1Wall2 = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, lectureHall1Depth), innerWallMaterial);
                    lectureHall1Wall2.position.set(position.x - width / 2 + lectureHall1Width, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2 + lectureHall1Depth / 2);

                    const lectureHall2Width = 8;
                    const lectureHall2Depth = 6;
                    const lectureHall2Wall1 = new THREE.Mesh(new THREE.BoxGeometry(lectureHall2Width, floorHeight, wallThickness), innerWallMaterial);
                    lectureHall2Wall1.position.set(position.x + width / 2 - lectureHall2Width / 2, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2 + lectureHall2Depth);
                    const lectureHall2Wall2 = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, lectureHall2Depth), innerWallMaterial);
                    lectureHall2Wall2.position.set(position.x + width / 2 - lectureHall2Width, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2 + lectureHall2Depth / 2);

                    const officeWidth = 4;
                    const officeDepth = 4;
                    const officeWall1 = new THREE.Mesh(new THREE.BoxGeometry(officeWidth, floorHeight, wallThickness), innerWallMaterial);
                    officeWall1.position.set(position.x + width / 2 - officeWidth / 2, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2 - officeDepth);
                    const officeWall2 = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, officeDepth), innerWallMaterial);
                    officeWall2.position.set(position.x + width / 2 - officeWidth, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2 - officeDepth / 2);

                    meshes.push(lectureHall1Wall1, lectureHall1Wall2, lectureHall2Wall1, lectureHall2Wall2, officeWall1, officeWall2);
                    innerCollisionBoxes[f].push(
                        new THREE.Box3().setFromObject(lectureHall1Wall1),
                        new THREE.Box3().setFromObject(lectureHall1Wall2),
                        new THREE.Box3().setFromObject(lectureHall2Wall1),
                        new THREE.Box3().setFromObject(lectureHall2Wall2),
                        new THREE.Box3().setFromObject(officeWall1),
                        new THREE.Box3().setFromObject(officeWall2)
                    );
                } else if (type === 'dorm') {
                    const corridorWidth = 4;
                    const corridorWall1 = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, depth - 4), innerWallMaterial);
                    corridorWall1.position.set(position.x - width / 2 + corridorWidth, position.y + f * floorHeight + floorHeight / 2, position.z);
                    const corridorWall2 = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, depth - 4), innerWallMaterial);
                    corridorWall2.position.set(position.x + width / 2 - corridorWidth, position.y + f * floorHeight + floorHeight / 2, position.z);

                    const roomDepth = 4;
                    const roomWidth = 4;
                    for (let i = 0; i < 3; i++) {
                        const leftRoomWall = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, floorHeight, wallThickness), innerWallMaterial);
                        leftRoomWall.position.set(position.x - width / 2 + corridorWidth + roomWidth / 2, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2 + (i + 1) * roomDepth);
                        const rightRoomWall = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, floorHeight, wallThickness), innerWallMaterial);
                        rightRoomWall.position.set(position.x + width / 2 - corridorWidth - roomWidth / 2, position.y + f * floorHeight + floorHeight / 2, position.z - depth / 2 + (i + 1) * roomDepth);

                        meshes.push(leftRoomWall, rightRoomWall);
                        innerCollisionBoxes[f].push(
                            new THREE.Box3().setFromObject(leftRoomWall),
                            new THREE.Box3().setFromObject(rightRoomWall)
                        );
                    }

                    const loungeWidth = 6;
                    const loungeDepth = 4;
                    const loungeWall1 = new THREE.Mesh(new THREE.BoxGeometry(loungeWidth, floorHeight, wallThickness), innerWallMaterial);
                    loungeWall1.position.set(position.x - loungeWidth / 2, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2 - loungeDepth);
                    const loungeWall2 = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, loungeDepth), innerWallMaterial);
                    loungeWall2.position.set(position.x - loungeWidth, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2 - loungeDepth / 2);

                    meshes.push(corridorWall1, corridorWall2, loungeWall1, loungeWall2);
                    innerCollisionBoxes[f].push(
                        new THREE.Box3().setFromObject(corridorWall1),
                        new THREE.Box3().setFromObject(corridorWall2),
                        new THREE.Box3().setFromObject(loungeWall1),
                        new THREE.Box3().setFromObject(loungeWall2)
                    );
                } else if (type === 'misc') {
                    const smallRoomWidth = 4;
                    const smallRoomDepth = 4;
                    const smallRoomWall1 = new THREE.Mesh(new THREE.BoxGeometry(smallRoomWidth, floorHeight, wallThickness), innerWallMaterial);
                    smallRoomWall1.position.set(position.x + width / 2 - smallRoomWidth / 2, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2 - smallRoomDepth);
                    const smallRoomWall2 = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, smallRoomDepth), innerWallMaterial);
                    smallRoomWall2.position.set(position.x + width / 2 - smallRoomWidth, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2 - smallRoomDepth / 2);

                    const smallRoom2Wall1 = new THREE.Mesh(new THREE.BoxGeometry(smallRoomWidth, floorHeight, wallThickness), innerWallMaterial);
                    smallRoom2Wall1.position.set(position.x - width / 2 + smallRoomWidth / 2, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2 - smallRoomDepth);
                    const smallRoom2Wall2 = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, floorHeight, smallRoomDepth), innerWallMaterial);
                    smallRoom2Wall2.position.set(position.x - width / 2 + smallRoomWidth, position.y + f * floorHeight + floorHeight / 2, position.z + depth / 2 - smallRoomDepth / 2);

                    meshes.push(smallRoomWall1, smallRoomWall2, smallRoom2Wall1, smallRoom2Wall2);
                    innerCollisionBoxes[f].push(
                        new THREE.Box3().setFromObject(smallRoomWall1),
                        new THREE.Box3().setFromObject(smallRoomWall2),
                        new THREE.Box3().setFromObject(smallRoom2Wall1),
                        new THREE.Box3().setFromObject(smallRoom2Wall2)
                    );
                }
            }

            // Create ramps
            if (floors > 1 && (type === 'classroom' || type === 'dorm')) {
                for (let f = 0; f < floors - 1; f++) {
                    const rampWidth = 2;
                    const rampLength = 4;
                    const rampHeight = floorHeight;
                    const rampGeometry = new THREE.PlaneGeometry(rampWidth, Math.sqrt(rampLength * rampLength + rampHeight * rampHeight));
                    const rampMaterial = new THREE.MeshBasicMaterial({ color: 0x555555, side: THREE.DoubleSide });
                    const rampMesh = new THREE.Mesh(rampGeometry, rampMaterial);

                    const rampX = position.x + (type === 'classroom' ? 10 : 8);
                    const rampZ = position.z - 10;
                    const rampY = position.y + f * floorHeight + rampHeight / 2;
                    rampMesh.position.set(rampX, rampY, rampZ);
                    const angle = Math.atan2(rampHeight, rampLength);
                    rampMesh.rotation.x = -angle;

                    meshes.push(rampMesh);
                    const rampStartZ = rampZ - rampLength / 2;
                    const rampEndZ = rampZ + rampLength / 2;
                    const rampStartY = position.y + f * floorHeight;
                    const rampEndY = position.y + (f + 1) * floorHeight;
                    rampPositions[f] = { x: rampX, startZ: rampStartZ, endZ: rampEndZ, startY: rampStartY, endY: rampEndY, floor: f };
                }
            }

            const buildingBox = new THREE.Box3().setFromCenterAndSize(position, new THREE.Vector3(width, totalHeight, depth));
            return { meshes, floorMeshes, outerCollisionBoxes, innerCollisionBoxes, rampPositions, buildingBox, floors, floorHeight, position };
        }

        // Create buildings
        const buildings = [
            createBuilding('dorm', new THREE.Vector3(20, 0, 20)),
            createBuilding('dorm', new THREE.Vector3(-30, 0, -30)),
            createBuilding('classroom', new THREE.Vector3(50, 0, 50)),
            createBuilding('classroom', new THREE.Vector3(-60, 0, 60)),
            createBuilding('misc', new THREE.Vector3(80, 0, 80)),
            createBuilding('misc', new THREE.Vector3(-80, 0, -80)),
            createBuilding('dorm', new THREE.Vector3(100, 0, 0)),
            createBuilding('classroom', new THREE.Vector3(0, 0, 100)),
            createBuilding('misc', new THREE.Vector3(-100, 0, 0)),
            createBuilding('dorm', new THREE.Vector3(0, 0, -100))
        ];
        buildings.forEach(building => building.meshes.forEach(mesh => scene.add(mesh)));

        // Raycaster for camera collision
        const raycaster = new THREE.Raycaster();

        function animate() {
            requestAnimationFrame(animate);

            // Update target camera distance
            targetCameraDistance = currentBuilding ? cameraDistanceInside : cameraDistanceOutside;
            cameraDistance += (targetCameraDistance - cameraDistance) * 0.1;
            cameraDistance = Math.max(minCameraDistance, Math.min(maxCameraDistance, cameraDistance));

            // Calculate ideal camera position
            const cameraOffset = new THREE.Vector3(
                cameraDistance * Math.sin(cameraYaw) * Math.cos(cameraPitch),
                cameraDistance * Math.sin(cameraPitch),
                cameraDistance * Math.cos(cameraYaw) * Math.cos(cameraPitch)
            );
            const idealCameraPosition = player.position.clone().add(cameraOffset);

            // Raycast from player to camera to detect obstructions
            const direction = idealCameraPosition.clone().sub(player.position).normalize();
            raycaster.set(player.position, direction);
            const intersects = raycaster.intersectObjects(scene.children, true);

            let adjustedCameraPosition = idealCameraPosition.clone();
            if (intersects.length > 0 && intersects[0].distance < cameraDistance) {
                const maxDistance = Math.max(minCameraDistance, intersects[0].distance - 0.5);
                adjustedCameraPosition.copy(player.position).add(direction.multiplyScalar(maxDistance));
            }

            // Ensure camera stays above player's feet
            adjustedCameraPosition.y = Math.max(adjustedCameraPosition.y, player.position.y - 0.5);

            camera.position.copy(adjustedCameraPosition);
            camera.lookAt(player.position);

            // Player movement
            const cameraForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            cameraForward.y = 0;
            cameraForward.normalize();
            const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            cameraRight.y = 0;
            cameraRight.normalize();

            let newPosition = player.position.clone();
            if (keys.w) newPosition.add(cameraForward.clone().multiplyScalar(moveSpeed));
            if (keys.s) newPosition.add(cameraForward.clone().multiplyScalar(-moveSpeed));
            if (keys.a) newPosition.add(cameraRight.clone().multiplyScalar(-moveSpeed));
            if (keys.d) newPosition.add(cameraRight.clone().multiplyScalar(moveSpeed));

            // Building and ramp logic
            let isInside = false;
            buildings.forEach(building => {
                if (building.buildingBox.containsPoint(newPosition)) {
                    currentBuilding = building;
                    isInside = true;
                }
            });
            if (!isInside) {
                currentBuilding = null;
                currentFloor = 0;
                newPosition.y = 0.5;
            } else {
                // Calculate current floor based on previous Y position
                currentFloor = Math.round((player.position.y - currentBuilding.position.y - 0.5) / currentBuilding.floorHeight);
                currentFloor = Math.max(0, Math.min(currentBuilding.floors - 1, currentFloor));

                // Check if on ramp
                let onRamp = false;
                for (let f = 0; f < currentBuilding.floors - 1; f++) {
                    const ramp = currentBuilding.rampPositions[f];
                    if (Math.abs(newPosition.x - ramp.x) < 1 && newPosition.z >= ramp.startZ && newPosition.z <= ramp.endZ) {
                        const t = (newPosition.z - ramp.startZ) / (ramp.endZ - ramp.startZ);
                        newPosition.y = ramp.startY + t * (ramp.endY - ramp.startY) + 0.5;
                        onRamp = true;
                        break;
                    }
                }
                if (!onRamp) {
                    const floorY = currentBuilding.position.y + currentFloor * currentBuilding.floorHeight;
                    newPosition.y = floorY + 0.5;
                }
            }

            // Collision detection
            let collision = false;
            const playerBox = new THREE.Box3().setFromCenterAndSize(newPosition, new THREE.Vector3(1, 1, 1));
            if (currentBuilding) {
                const collisionBoxes = [...currentBuilding.outerCollisionBoxes[currentFloor], ...currentBuilding.innerCollisionBoxes[currentFloor]];
                for (let box of collisionBoxes) {
                    if (playerBox.intersectsBox(box)) {
                        collision = true;
                        break;
                    }
                }
            } else {
                for (let building of buildings) {
                    for (let floorBoxes of building.outerCollisionBoxes) {
                        for (let box of floorBoxes) {
                            if (playerBox.intersectsBox(box)) {
                                collision = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (!collision) player.position.copy(newPosition);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>